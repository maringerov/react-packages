{"version":3,"sources":["/packages/babel-runtime/babel-runtime.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iH","file":"/packages/babel-runtime.js","sourcesContent":["// The name `babelHelpers` is hard-coded in Babel.  Otherwise we would make it\n// something capitalized and more descriptive, like `BabelRuntime`.\nbabelHelpers = {\n  // Constructs the object passed to the tag function in a tagged\n  // template literal.\n  taggedTemplateLiteralLoose: function (strings, raw) {\n    // Babel's own version of this calls Object.freeze on `strings` and\n    // `strings.raw`, but it doesn't seem worth the compatibility and\n    // performance concerns.  If you're writing code against this helper,\n    // don't add properties to these objects.\n    strings.raw = raw;\n    return strings;\n  },\n\n  // Checks that a class constructor is being called with `new`, and throws\n  // an error if it is not.\n  classCallCheck: function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  },\n\n  inherits: function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    if (superClass) {\n      if (Object.create) {\n        // All but IE 8\n        subClass.prototype = Object.create(superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n      } else {\n        // IE 8 path.  Slightly worse for modern browsers, because `constructor`\n        // is enumerable and shows up in the inspector unnecessarily.\n        // It's not an \"own\" property of any instance though.\n        //\n        // For correctness when writing code,\n        // don't enumerate all the own-and-inherited properties of an instance\n        // of a class and expect not to find `constructor` (but who does that?).\n        var F = function () {\n          this.constructor = subClass;\n        };\n        F.prototype = superClass.prototype;\n        subClass.prototype = new F();\n      }\n\n      // For modern browsers, this would be `subClass.__proto__ = superClass`,\n      // but IE <=10 don't support `__proto__`, and in this case the difference\n      // would be detectable; code that works in modern browsers could easily\n      // fail on IE 8 if we ever used the `__proto__` trick.\n      //\n      // There's no perfect way to make static methods inherited if they are\n      // assigned after declaration of the classes.  The best we can do is\n      // to copy them.  In other words, when you write `class Foo\n      // extends Bar`, we copy the static methods from Bar onto Foo, but future\n      // ones are not copied.\n      //\n      // For correctness when writing code, don't add static methods to a class\n      // after you subclass it.\n      for (var k in superClass) {\n        if (_hasOwnProperty.call(superClass, k)) {\n          subClass[k] = superClass[k];\n        }\n      }\n    }\n  },\n  // used by es7.objectRestSpread and JSX\n  _extends: Object.assign || (function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (_hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  }),\n  // used by es6.destructuring\n  objectWithoutProperties: function (obj, keys) {\n    var target = {};\n    for (var i in obj) {\n      if (keys.indexOf(i) >= 0) continue;\n      if (! _hasOwnProperty.call(obj, i)) continue;\n      target[i] = obj[i];\n    }\n    return target;\n  },\n  // used by es6.destructuring\n  objectDestructuringEmpty: function (obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  }\n};\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n"]}